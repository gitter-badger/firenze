{"name":"firenze.js","tagline":"Adapter based JavaScript ORM for Node.js and the browser","body":"# firenze.js\r\n\r\n[![Build Status](https://secure.travis-ci.org/fahad19/firenze.png?branch=master)](http://travis-ci.org/fahad19/firenze) [![Coverage Status](https://coveralls.io/repos/fahad19/firenze/badge.svg?branch=master)](https://coveralls.io/r/fahad19/firenze?branch=master) [![npm](https://img.shields.io/npm/v/firenze.svg)](https://www.npmjs.com/package/firenze)\r\n\r\nInstall it with [npm](https://npmjs.com):\r\n\r\n```\r\n$ npm install --save firenze\r\n```\r\n\r\nOr [Bower](http://bower.io):\r\n\r\n```\r\n$ bower install --save firenze\r\n```\r\n\r\n---\r\n\r\nfirenze.js is a adapter-based object relational mapper targetting node.js, io.js and the browser.\r\n\r\n**Key features:**\r\n\r\n* Written in ES6 (works in both node/io.js/browser)\r\n* Adapter based structure to plug in any database\r\n* Promise based workflow\r\n* Strong validation support\r\n\r\nThe project is still in heavy development, and more features are expected to land in future releases.\r\n\r\n**Available adapters:**\r\n\r\n* [MySQL](https://github.com/fahad19/firenze-adapter-mysql)\r\n\r\n**Terminologies:**\r\n\r\nTerminologies for developing with firenze.js can be broken down into a handful of items:\r\n\r\n* Database\r\n* Adapter\r\n* Collection\r\n* Model\r\n\r\nEach of them are discussed in the documentation below.\r\n\r\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\r\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\r\n# Contents\r\n\r\n- [Install](#install)\r\n  - [Node.js](#nodejs)\r\n  - [io.js](#iojs)\r\n  - [Browser](#browser)\r\n- [Quickstart](#quickstart)\r\n- [Database](#database)\r\n  - [Usage](#usage)\r\n  - [Methods](#methods)\r\n    - [createCollectionClass(extend)](#createcollectionclassextend)\r\n    - [createModelClass(extend)](#createmodelclassextend)\r\n    - [getAdapter()](#getadapter)\r\n    - [getConnection()](#getconnection)\r\n    - [close(cb = null)](#closecb--null)\r\n- [Adapter](#adapter)\r\n  - [Usage](#usage-1)\r\n  - [Methods](#methods-1)\r\n    - [getConnection()](#getconnection-1)\r\n    - [closeConnection(cb = null)](#closeconnectioncb--null)\r\n    - [query()](#query)\r\n    - [create(q, obj)](#createq-obj)\r\n    - [read(q)](#readq)\r\n    - [update(q, obj)](#updateq-obj)\r\n    - [delete(q)](#deleteq)\r\n    - [dropTable(model)](#droptablemodel)\r\n    - [createTable(model)](#createtablemodel)\r\n    - [populateTable(model, rows)](#populatetablemodel-rows)\r\n    - [loadFixture(model, rows)](#loadfixturemodel-rows)\r\n    - [loadAllFixtures(arr)](#loadallfixturesarr)\r\n- [Collection](#collection)\r\n  - [Creating classes](#creating-classes)\r\n    - [Properties](#properties)\r\n      - [modelClass](#modelclass)\r\n      - [table](#table)\r\n      - [finders](#finders)\r\n  - [Usage](#usage-2)\r\n  - [Methods](#methods-2)\r\n    - [model(attributes = {}, extend = {})](#modelattributes---extend--)\r\n    - [getDatabase()](#getdatabase)\r\n    - [getAdapter()](#getadapter-1)\r\n    - [setDatabase(db)](#setdatabasedb)\r\n    - [query(options = {})](#queryoptions--)\r\n    - [find(type, options = {})](#findtype-options--)\r\n    - [findAll(options = {})](#findalloptions--)\r\n    - [findFirst(options = {})](#findfirstoptions--)\r\n    - [findCount(options = {})](#findcountoptions--)\r\n    - [findList(options = {})](#findlistoptions--)\r\n    - [save(model, options = {})](#savemodel-options--)\r\n    - [delete(model)](#deletemodel)\r\n- [Models](#models)\r\n  - [Creating classes](#creating-classes-1)\r\n    - [Properties](#properties-1)\r\n      - [collectionClass](#collectionclass)\r\n      - [schema](#schema)\r\n      - [attributes](#attributes)\r\n      - [primaryKey](#primarykey)\r\n      - [displayField](#displayfield)\r\n      - [id](#id)\r\n      - [validationRules](#validationrules)\r\n      - [alias](#alias)\r\n  - [Usage](#usage-3)\r\n  - [Validations](#validations)\r\n    - [Single rule](#single-rule)\r\n    - [Multiple rules](#multiple-rules)\r\n    - [Rule with options](#rule-with-options)\r\n    - [Rule as a function](#rule-as-a-function)\r\n    - [Asynchronouse rule](#asynchronouse-rule)\r\n    - [Available rules](#available-rules)\r\n    - [Custom rules](#custom-rules)\r\n    - [Required fields](#required-fields)\r\n  - [Methods](#methods-3)\r\n    - [collection(options = {})](#collectionoptions--)\r\n    - [get(field)](#getfield)\r\n    - [set(field, value)](#setfield-value)\r\n    - [toObject()](#toobject)\r\n    - [toJSON()](#tojson)\r\n    - [fetch(options = {})](#fetchoptions--)\r\n    - [getId()](#getid)\r\n    - [isNew()](#isnew)\r\n    - [save(options = {})](#saveoptions--)\r\n    - [saveField(field, value)](#savefieldfield-value)\r\n    - [clear()](#clear)\r\n    - [delete(options = {})](#deleteoptions--)\r\n    - [validate()](#validate)\r\n    - [validateField(field, value = null)](#validatefieldfield-value--null)\r\n  - [Callbacks](#callbacks)\r\n    - [beforeSave()](#beforesave)\r\n    - [afterSave()](#aftersave)\r\n    - [beforeValidate()](#beforevalidate)\r\n    - [afterValidate()](#aftervalidate)\r\n    - [beforeDelete()](#beforedelete)\r\n    - [afterDelete()](#afterdelete)\r\n- [Testing](#testing)\r\n- [License](#license)\r\n\r\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\r\n\r\n# Install\r\n\r\nfirenze.js can be used in both node.js/io.js, as well as the browser.\r\n\r\n## Node.js\r\n\r\n```\r\n$ npm install --save firenze\r\n```\r\n\r\nNow you can require it as follows:\r\n\r\n```js\r\nvar firenze = require('firenze');\r\n```\r\n\r\n## io.js\r\n\r\nInstallation is same as Node.js since `npm` is the common package manager.\r\n\r\nTo import:\r\n\r\n```js\r\nimport firenze from 'firenze';\r\n```\r\n\r\n## Browser\r\n\r\nYou can download firenze.js using [Bower](http://bower.io).\r\n\r\n```js\r\n$ bower install --save firenze\r\n```\r\n\r\nThe package comes with multiple dist files, and you are free to choose whatever workflow suits you best.\r\n\r\nIf you want to include just one file alone with all the dependencies:\r\n\r\n```html\r\n<script src=\"bower_components/firenze/dist/firenze.full.min.js\"></script>\r\n\r\n<script>\r\n// the library is now available in `firenze` variable\r\n</script>\r\n```\r\n\r\nIf you wish to include only the core library, and load its dependencies manually:\r\n\r\n```html\r\n<script src=\"bower_components/lodash/lodash.min.js\"></script>\r\n<script src=\"bower_components/async/lib/async.js\"></script>\r\n<script src=\"bower_components/bluebird/js/browser/bluebird.min.js\"></script>\r\n<script src=\"bower_components/validator-js/validator.min.js\"></script>\r\n\r\n<script src=\"bower_components/firenze/dist/firenze.min.js\"></script>\r\n\r\n<script>\r\n// use `firenze` variable to access the library\r\n</script>\r\n```\r\n\r\n# Quickstart\r\n\r\nThe example is targetting Node.js environment.\r\n\r\nInstall the module (along with an adapter) first:\r\n\r\n```\r\n$ npm install --save firenze firenze-adapter-mysql\r\n```\r\n\r\nNow you can proceed to managing your database as folllows:\r\n\r\n```js\r\nvar f = require('firenze');\r\nvar Database = f.Database;\r\nvar MysqlAdapter = require('firenze-adapter-mysql');\r\n\r\n// create an instance of your Database\r\nvar db = new Database({\r\n  adapter: MysqlAdapter,\r\n  host: '127.0.0.1',\r\n  database: 'my_database',\r\n  user: '',\r\n  password: ''\r\n});\r\n\r\n// define a Collection, which represents a table\r\nvar Posts = db.createCollectionClass({ // or db.Collection()\r\n  table: 'posts',\r\n\r\n  modelClass: function () {\r\n    return Post;\r\n  }\r\n  // or modelClass: Post\r\n});\r\n\r\n// define a Model, which represents a record\r\nvar Post = db.createModelClass({ // or db.Model()\r\n  alias: 'Post',\r\n\r\n  collectionClass: Posts, // or a function that returns Posts\r\n\r\n  schema: {\r\n    id: {\r\n      type: 'integer'\r\n    },\r\n    title: {\r\n      type: 'string'\r\n    },\r\n    body: {\r\n      type: 'text'\r\n    }\r\n  }\r\n});\r\n\r\n// finding\r\nvar posts = new Posts();\r\nposts.find('first', {\r\n  conditions: {\r\n    id: 1\r\n    // can also be prefixed with Model alias as:\r\n    // 'Post.id': 1\r\n  }\r\n}).then(function (post) {\r\n  // post in an instance of Model, with fetched data\r\n  var title = post.get('title');\r\n\r\n  // or convert to plain object\r\n  var postObject = post.toObject();\r\n  var title = postObject.title;\r\n});\r\n\r\n// saving\r\nvar post = new Post({\r\n  title: 'Hello World',\r\n  body: 'blah...'\r\n});\r\npost.save().then(function (model) {\r\n  console.log('Saved with ID: ' + model.get('id'));\r\n});\r\n```\r\n\r\n<!--docume:src/Database.js-->\r\n# Database\r\n\r\nBefore anything else, you need to create an instance of `Database` with your credentials which will be referenced in your Collections and Models.\r\n\r\n## Usage\r\n\r\n```js\r\nvar f = require('firenze');\r\nvar Database = f.Database;\r\nvar MysqlAdapter = require('firenze-adapter-mysql');\r\n\r\nvar db = new Database({\r\n  adapter: MysqlAdapter,\r\n  host: '127.0.0.1',\r\n  database: 'my_database',\r\n  user: '',\r\n  password: '',\r\n  pool: {\r\n    min: 0,\r\n    max: 1\r\n  }\r\n});\r\n```\r\n## Methods\r\n\r\n### createCollectionClass(extend)\r\n\r\nAlso aliased as `.Collection(extend)`.\r\n\r\n### createModelClass(extend)\r\n\r\nAlso aliased as `.Model(extend)`\r\n\r\n### getAdapter()\r\n\r\nReturns adapter\r\n\r\n### getConnection()\r\n\r\nReturns connection of the Adapter\r\n\r\n### close(cb = null)\r\n\r\nCloses the connection\r\n\r\n<!--/docume:src/Database.js-->\r\n\r\n<!--docume:src/Adapter.js-->\r\n# Adapter\r\n\r\nAdapter is responsible for making the actual database operations.\r\n\r\n## Usage\r\n\r\nYou would hardly ever need to create an instance of a Adapter. Database class would take care of it.\r\n\r\nAn adapter instance is created with the same options passed when creating a Database instance:\r\n\r\nFor example, if you are using MySQL adapter, it would be like this:\r\n\r\n```\r\n$ npm install --save firenze-adapter-mysql\r\n```\r\n\r\nNow let's create an instance of Database:\r\n\r\n```js\r\nvar f = require('firenze');\r\nvar Database = f.Database;\r\nvar MysqlAdapter = require('firenze-adapter-mysql');\r\n\r\nvar db = new Database({\r\n  adapter: MysqlAdapter,\r\n  host: '127.0.0.1',\r\n  database: 'my_database',\r\n  user: '',\r\n  password: ''\r\n});\r\n```\r\n\r\n## Methods\r\n\r\nEvery adapter needs to implement at least these methods below:\r\n\r\n### getConnection()\r\n\r\nReturns the current connection\r\n\r\n### closeConnection(cb = null)\r\n\r\nCloses the current connection, and calls the callback function `cb()` if passed.\r\n\r\n### query()\r\n\r\nGets a query object\r\n\r\n### create(q, obj)\r\n\r\nCreates a new record\r\n\r\n### read(q)\r\n\r\nFetches the results found against the query object\r\n\r\n### update(q, obj)\r\n\r\nUpdates the records matching againt query object with given data\r\n\r\n### delete(q)\r\n\r\nDeletes the records matching against query object\r\n\r\n### dropTable(model)\r\n\r\nDrop table if exists\r\n\r\n### createTable(model)\r\n\r\nCreate table based on model's schema\r\n\r\n### populateTable(model, rows)\r\n\r\nInsert rows into model's table\r\n\r\n### loadFixture(model, rows)\r\n\r\nCreates table, and loads data for given model\r\n\r\n### loadAllFixtures(arr)\r\n\r\nRuns fixtures for multiple models\r\n\r\narr = [{model: post, rows: rows}]\r\n\r\n<!--/docume:src/Adapter.js-->\r\n\r\n<!--docume:src/Collection.js-->\r\n# Collection\r\n\r\nA collection represents a table. If you have a `posts` table, most likely you would have a collection for it called `Posts`.\r\n\r\n## Creating classes\r\n\r\nYou can create a Collection class from your Database instance. And it requires minimum two properies, `table`, and `modelClass`:\r\n\r\n```js\r\nvar Posts = db.createCollectionClass({\r\n  table: 'posts',\r\n\r\n  modelClass: function () {\r\n    return Post;\r\n  }\r\n});\r\n```\r\n\r\nThere is also a short method for creating Collection class via `db.Collection()`.\r\n\r\nYou can also create a Collection class like this:\r\n\r\n```js\r\nvar Posts = f.createCollectionClass({\r\n  db: db, // instance of your Database\r\n\r\n  table: 'posts',\r\n\r\n  // ...\r\n});\r\n```\r\n\r\nIf you are using ES6:\r\n\r\n```js\r\nclass Posts extends f.Collection {\r\n  constructor(extend = {}) {\r\n    super(extend);\r\n    this.setDatabase(db);\r\n  }\r\n}\r\n```\r\n\r\n### Properties\r\n\r\n#### modelClass\r\n\r\nEvery collection requires a Model for representing its records. This property can directly reference to the Model class, or it can be a function that returns the Model class.\r\n\r\n#### table\r\n\r\nThe name of the table that this Collection represents. Always as a string.\r\n\r\n#### finders\r\n\r\nList of mapped finder methods that you want available in `.find(mappedName, options)`\r\n\r\nBy default these are set:\r\n\r\n```js\r\n{\r\n  all: 'findAll',\r\n  first: 'findFirst',\r\n  count: 'findCount',\r\n  list: 'findList'\r\n}\r\n```\r\n\r\nThis mapping allows you to later call `.find('all', options)`, which eventually calls `.findAll(options)`.\r\n\r\n## Usage\r\n\r\nBefore using the Collection, you need to create an instance of it:\r\n\r\n```js\r\nvar posts = new Posts();\r\n```\r\n\r\n## Methods\r\n\r\n### model(attributes = {}, extend = {})\r\n\r\nGet an instance of this Collection's model\r\n\r\n### getDatabase()\r\n\r\nGet in instance of the current Database\r\n\r\n### getAdapter()\r\n\r\nGet adapter of the Collections' database\r\n\r\n### setDatabase(db)\r\n\r\nChange database instance of this Collection to `db`\r\n\r\n### query(options = {})\r\n\r\nGet query object for this Collection\r\n\r\n### find(type, options = {})\r\n\r\nExplained above in `finders` section\r\n\r\n### findAll(options = {})\r\n\r\nReturns a promise with matched results.\r\n\r\nSame as `collection.find('all', options)`.\r\n\r\n### findFirst(options = {})\r\n\r\nReturns a promise with matched model if any.\r\n\r\nSame as `collection.find('first', options)`.\r\n\r\n### findCount(options = {})\r\n\r\nReturns a promise with count of matched results.\r\n\r\nSame as `collection.find('count', options)`.\r\n\r\n### findList(options = {})\r\n\r\nReturns a promise with key/value pair of matched results.\r\n\r\nSame as `collection.find('list', options)`.\r\n\r\n### save(model, options = {})\r\n\r\nSave the given model. This method is not usually called directly, but rather via `Model.save()`.\r\n\r\nReturns a promise with model instance.\r\n\r\n### delete(model)\r\n\r\nDeletes the given model. Usually called via `Model.delete()`.\r\n\r\nReturns a promise.\r\n\r\n<!--/docume:src/Collection.js-->\r\n\r\n<!--docume:src/Model.js-->\r\n# Models\r\n\r\nA model represents a record of a table. If you have a `posts` table, most likely you would want to name your Model class in its singular for, which is `Post`.\r\n\r\n## Creating classes\r\n\r\nYou can create a Model class from your Database instance. And it can be created as follows:\r\n\r\n```js\r\nvar Post = db.createModelClas({\r\n  alias: 'Post',\r\n\r\n  displayField: 'title',\r\n\r\n  schema: {\r\n    id: {\r\n      type: 'increments'\r\n    },\r\n    title: {\r\n      type: 'string'\r\n    }\r\n  },\r\n\r\n  collectionClass: Posts\r\n});\r\n```\r\n\r\nThere is a short method for creating a Model class via `db.Model()`.\r\n\r\nYou can also create a Model class like this:\r\n\r\n```js\r\nvar Post = f.createModelClass({\r\n  // ...\r\n});\r\n```\r\n\r\nIf you are using ES6:\r\n\r\n```js\r\nclass Post extends f.Model {\r\n  constructor(attributes = {}, extend = {}) {\r\n    super(attributes, extend);\r\n  }\r\n}\r\n```\r\n\r\n### Properties\r\n\r\n#### collectionClass\r\n\r\nJust like how Collection has a modelClass, models also need to have a collectionClass. It can be a direct reference to the class, or it can be a function that returns the class.\r\n\r\n#### schema\r\n\r\nModels do not necessarily need to define their full schema, but you would need them for building fixtures and also assigning validation rules for example later.\r\n\r\nThe keys of this object are the column names, and the value defines what type of column they are. For example:\r\n\r\n```js\r\n{\r\n  id: {\r\n    type: 'integer'\r\n  },\r\n  title: {\r\n    type: 'string'\r\n  }\r\n}\r\n```\r\n\r\nColumn types can vary depending on the adapter you are using.\r\n\r\nYou also use the `schema` property to set validation rules.\r\n\r\nFor example:\r\n\r\n```js\r\n{\r\n  email: {\r\n    type: 'string',\r\n    validate: {\r\n      rule: 'isEmail',\r\n      message: 'Please enter a valid email address'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nValidations will be discussed further later in its own section.\r\n\r\n#### attributes\r\n\r\nYour model's data\r\n\r\n#### primaryKey\r\n\r\nThe name of the ID field, defaults to `id`.\r\n\r\n#### displayField\r\n\r\nThis is the field that represents your record's display value. Usually `title` or `name` in most cases.\r\n\r\n#### id\r\n\r\nFor convenience, stores the ID of the model in this property\r\n\r\n#### validationRules\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  ruleName: function (field, value) {\r\n    return true;\r\n  },\r\n  asyncRule: function (value, field, validated) {\r\n    return validated(true);\r\n  },\r\n  ruleWithOptions: function (value, field, arg1, arg2) {\r\n    return true;\r\n  }\r\n}\r\n```\r\n\r\n#### alias\r\n\r\nUnless defined, alias always defaults to the table name as defined in the Collection class of a Model. When associations get in the way, having a unique alias helps avoiding ambiguity when constructing complex conditions.\r\n\r\n## Usage\r\n\r\nUnless otherwise you are already provided with a model instance from a Collection, you need to create an instance of it:\r\n\r\n```js\r\nvar post = new Post();\r\n```\r\n\r\nYou can also create an instance of a Model with some data:\r\n\r\n```js\r\nvar post = new Post({\r\n  title: 'Hello World',\r\n  body: 'blah...'\r\n});\r\n```\r\n\r\n## Validations\r\n\r\nValidation rules for fields can be set when defining the schema:\r\n\r\n### Single rule\r\n\r\n```js\r\ndb.createModelClass({\r\n  schema: {\r\n    email: {\r\n      type: 'string',\r\n      validate: {\r\n        rule: 'isEmail',\r\n        message: 'Please enter a valid email address'\r\n      }\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n### Multiple rules\r\n\r\n```js\r\n{\r\n  email: {\r\n    type: 'string',\r\n    validate: [\r\n      {\r\n        rule: 'isLowercase',\r\n        message: 'Please enter email address in lowercase',\r\n      },\r\n      {\r\n        rule: 'isEmail',\r\n        message: 'Please enter a valid email address'\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n### Rule with options\r\n\r\n```js\r\n{\r\n  fruit: {\r\n    type: 'string',\r\n    validate: {\r\n      rule: [\r\n       'isIn', // `isIn` is the rule name\r\n       [\r\n         'apple',\r\n         'banana'\r\n       ] // this array is passed as an argument to rule function\r\n      ],\r\n      message: 'Must be either apple or banana'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Rule as a function\r\n\r\n```js\r\n{\r\n  mood: {\r\n    type: 'string',\r\n    validate: {\r\n      rule: function (field, value) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Asynchronouse rule\r\n\r\n```js\r\n{\r\n  food: {\r\n    type: 'string',\r\n    validate: {\r\n      rule: function (field, value, done) {\r\n        checkIfFoodIsHealthy(value, function (healthy) {\r\n          var isHealthy = healthy === true;\r\n          done(isHealthy);\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Available rules\r\n\r\nBy default, all the validation rules from [Validator.js](https://github.com/chriso/validator.js#validators) is available:\r\n\r\n- **equals(str, comparison)** - check if the string matches the comparison.\r\n- **contains(str, seed)** - check if the string contains the seed.\r\n- **matches(str, pattern [, modifiers])** - check if string matches the pattern. Either `matches('foo', /foo/i)` or `matches('foo', 'foo', 'i')`.\r\n- **isEmail(str [, options])** - check if the string is an email. `options` is an object which defaults to `{ allow_display_name: false, allow_utf8_local_part: true }`. If `allow_display_name` is set to true, the validator will also match `Display Name <email-address>`. If `allow_utf8_local_part` is set to false, the validator will not allow any non-English UTF8 character in email address' local part.\r\n- **isURL(str [, options])** - check if the string is an URL. `options` is an object which defaults to `{ protocols: ['http','https','ftp'], require_tld: true, require_protocol: false, allow_underscores: false, host_whitelist: false, host_blacklist: false, allow_trailing_dot: false, allow_protocol_relative_urls: false }`.\r\n- **isFQDN(str [, options])** - check if the string is a fully qualified domain name (e.g. domain.com). `options` is an object which defaults to `{ require_tld: true, allow_underscores: false, allow_trailing_dot: false }`.\r\n- **isIP(str [, version])** - check if the string is an IP (version 4 or 6).\r\n- **isAlpha(str)** - check if the string contains only letters (a-zA-Z).\r\n- **isNumeric(str)** - check if the string contains only numbers.\r\n- **isAlphanumeric(str)** - check if the string contains only letters and numbers.\r\n- **isBase64(str)** - check if a string is base64 encoded.\r\n- **isHexadecimal(str)** - check if the string is a hexadecimal number.\r\n- **isHexColor(str)** - check if the string is a hexadecimal color.\r\n- **isLowercase(str)** - check if the string is lowercase.\r\n- **isUppercase(str)** - check if the string is uppercase.\r\n- **isInt(str [, options])** - check if the string is an integer. `options` is an object which can contain the keys `min` and/or `max` to check the integer is within boundaries (e.g. `{ min: 10, max: 99 }`).\r\n- **isFloat(str [, options])** - check if the string is a float. `options` is an object which can contain the keys `min` and/or `max` to validate the float is within boundaries (e.g. `{ min: 7.22, max: 9.55 }`).\r\n- **isDivisibleBy(str, number)** - check if the string is a number that's divisible by another.\r\n- **isNull(str)** - check if the string is null.\r\n- **isLength(str, min [, max])** - check if the string's length falls in a range. Note: this function takes into account surrogate pairs.\r\n- **isByteLength(str, min [, max])** - check if the string's length (in bytes) falls in a range.\r\n- **isUUID(str [, version])** - check if the string is a UUID (version 3, 4 or 5).\r\n- **isDate(str)** - check if the string is a date.\r\n- **isAfter(str [, date])** - check if the string is a date that's after the specified date (defaults to now).\r\n- **isBefore(str [, date])** - check if the string is a date that's before the specified date.\r\n- **isIn(str, values)** - check if the string is in a array of allowed values.\r\n- **isCreditCard(str)** - check if the string is a credit card.\r\n- **isISIN(str)** - check if the string is an [ISIN][ISIN] (stock/security identifier).\r\n- **isISBN(str [, version])** - check if the string is an ISBN (version 10 or 13).\r\n- **isMobilePhone(str, locale)** - check if the string is a mobile phone number, (locale is one of `['zh-CN', 'en-ZA', 'en-AU', 'en-HK', 'pt-PT', 'fr-FR', 'el-GR', 'en-GB', 'en-US', 'en-ZM']`).\r\n- **isJSON(str)** - check if the string is valid JSON (note: uses JSON.parse).\r\n- **isMultibyte(str)** - check if the string contains one or more multibyte chars.\r\n- **isAscii(str)** - check if the string contains ASCII chars only.\r\n- **isFullWidth(str)** - check if the string contains any full-width chars.\r\n- **isHalfWidth(str)** - check if the string contains any half-width chars.\r\n- **isVariableWidth(str)** - check if the string contains a mixture of full and half-width chars.\r\n- **isSurrogatePair(str)** - check if the string contains any surrogate pairs chars.\r\n- **isMongoId(str)** - check if the string is a valid hex-encoded representation of a [MongoDB ObjectId][mongoid].\r\n- **isCurrency(str, options)** - check if the string is a valid currency amount. `options` is an object which defaults to `{symbol: '$', require_symbol: false, allow_space_after_symbol: false, symbol_after_digits: false, allow_negatives: true, parens_for_negatives: false, negative_sign_before_digits: false, negative_sign_after_digits: false, allow_negative_sign_placeholder: false, thousands_separator: ',', decimal_separator: '.', allow_space_after_digits: false }`.\r\n\r\nExample usage of the above mentioned rules:\r\n\r\n```js\r\ndb.createModelClass({\r\n  schema: {\r\n    title: {\r\n      // direct rule\r\n      validate: {\r\n        rule: 'isAlphanumeric'\r\n      }\r\n    },\r\n    body: {\r\n      // rule with options\r\n      validate: {\r\n        rule: ['isLength', min, max]\r\n      }\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nBut of course, you can always override them or add new custom rules.\r\n\r\n### Custom rules\r\n\r\nValidation rules can be defined when creating a Model class:\r\n\r\n```js\r\nvar Post = db.createModelClass({\r\n  schema: {\r\n    name: {\r\n      type: 'string',\r\n      validate: {\r\n        rule: 'myFirstRule'\r\n      }\r\n    },\r\n    title: {\r\n      type: 'string',\r\n      validate: {\r\n        rule: [\r\n          'myRuleWithOptions',\r\n          'arg1 value',\r\n          'arg2 value'\r\n        ]\r\n      }\r\n    }\r\n  },\r\n\r\n  validationRules: {\r\n    myFirstRule: function (field, value) {\r\n      return true; // validated successfully\r\n    },\r\n    myRuleWithOptions: function (field, value, arg1, arg2) {\r\n      return true;\r\n    },\r\n    myAsyncRule: function (field, value, done) {\r\n      doSomething(value, function (result) {\r\n        var validated = result === true;\r\n        done(validated);\r\n      });\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n### Required fields\r\n\r\nBy default, validation rules are only checked against fields that are set.\r\n\r\nBut if you wish to make sure that certain fields are required, meaning they should always be present, you can mark them as required in your schema:\r\n\r\n```js\r\nvar Post = db.createModelClass({\r\n  schema: {\r\n    name: {\r\n      type: 'string',\r\n      validate: {\r\n        rule: 'isAlpha',\r\n        required: true,\r\n        message: 'Must be alphabets only'\r\n      }\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n## Methods\r\n\r\n### collection(options = {})\r\n\r\nGet the model's Collection's instance\r\n\r\n### get(field)\r\n\r\nGet the field of current model\r\n\r\n### set(field, value)\r\n\r\nSet an attribute with given value for the field\r\n\r\n### toObject()\r\n\r\nReturns a plain object of the model\r\n\r\n### toJSON()\r\n\r\nAlias of `.toObject()`.\r\n\r\n### fetch(options = {})\r\n\r\nFetches the model again from the Database, and returns it with a promise.\r\n\r\nA quick example:\r\n\r\n```js\r\nvar post = new Post({id: 1});\r\npost.fetch().then(function (model) {\r\n  var title = model.get('title');\r\n});\r\n```\r\n\r\n### getId()\r\n\r\nGet the ID of model\r\n\r\n### isNew()\r\n\r\nIs the current model new? As in saved in Database, or yet to be saved?\r\n\r\n### save(options = {})\r\n\r\nSave the current model, and returns a promise.\r\n\r\nOptions:\r\n\r\n* `callbacks`: Defaults to true, pass false to disable before/after callbacks.\r\n\r\n### saveField(field, value)\r\n\r\nSave a particular field with value.\r\n\r\nReturns a promise.\r\n\r\n### clear()\r\n\r\nClear the current instance of model of any data\r\n\r\n### delete(options = {})\r\n\r\nDelete the current model, and return a promise.\r\n\r\nOptions:\r\n\r\n* `callbacks`: Defaults to true, pass false to disable before/after callbacks.\r\n\r\n### validate()\r\n\r\nValidates all fields of the current Model\r\n\r\nReturns a promise with `true` if all validated, otherwise an object of error messages keyed by field names.\r\n\r\n@TODO: `reject()` instead on error?\r\n\r\nOptions:\r\n\r\n* `callbacks`: Defaults to true, pass false to disable before/after callbacks.\r\n\r\n### validateField(field, value = null)\r\n\r\nValidates a single field\r\n\r\nReturns a promise with true if validated, otherwise error message\r\n\r\n## Callbacks\r\n\r\nModels also support callbacks that you can define when creating classes.\r\n\r\nFor example:\r\n\r\n```js\r\nvar Promise = f.Promise;\r\nvar Post = f.createModelClass({\r\n  alias: 'Post',\r\n\r\n  beforeSave: function () {\r\n    // do something before saving...\r\n\r\n    // end the callback with a promise\r\n    return new Promise.resolve(true);\r\n  }\r\n});\r\n```\r\n\r\n### beforeSave()\r\n\r\nShould return a Promise with `true` to continue.\r\n\r\nTo stop the save, return a Promise with an error.\r\n\r\n### afterSave()\r\n\r\nShould return a Promise.\r\n\r\n### beforeValidate()\r\n\r\nShould return a Promise with `true` to continue.\r\n\r\nTo stop the validation, return a Promise with an error.\r\n\r\n### afterValidate()\r\n\r\nShould return a Promise.\r\n\r\n### beforeDelete()\r\n\r\nShould return a Promise with `true` to continue.\r\n\r\nTo stop from deleting, return a Promise with an error.\r\n\r\n### afterDelete()\r\n\r\nShould return a Promise.\r\n\r\n<!--/docume:src/Model.js-->\r\n\r\n<!--docume:node_modules/firenze-adapter-mysql/src/index.js-->\r\n<!--/docume:node_modules/firenze-adapter-mysql/src/index.js-->\r\n\r\n# Testing\r\n\r\nTests are written with [mocha](http://visionmedia.github.com/mocha/), and can be run via npm:\r\n\r\n```\r\n$ npm test\r\n```\r\n\r\n# License\r\n\r\nMIT © [Fahad Ibnay Heylaal](http://fahad19.com)\r\n","google":"UA-47493443-2","note":"Don't delete this file! It's used internally to help with page regeneration."}